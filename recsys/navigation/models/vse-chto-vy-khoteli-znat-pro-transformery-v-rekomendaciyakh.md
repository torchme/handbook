---
description: 'todo: показать типичные архитектуры в пунктах 1'
---

# Все что вы хотели знать про Трансформеры в Рекомендациях

## Подводка

Оказывается, трансформеры не только спасают мир от злодеев, но и помогают находить идеальный фильм на вечер или тот самый товар на распродаже. Пристегнитесь, мы погружаемся в Кибертрон трансформеров, но не тех, что превращаются в машины, а тех, что превращают данные в точные рекомендации!

## 1. С чего все начиналось

Прежде чем погрузиться в мир ~~Кибертрона~~ трансформеров и понять, как они изменили рекомендации, давайте вернемся на несколько лет назад и посмотрим, какие методы использовались до их появления. Рекомендательные системы прошли долгий путь, используя ряд проверенных и надежных подходов, которые были эффективны в своих контекстах. Но каждый из этих методов сталкивался с определенными ограничениями, которые и подготовили почву для появления новых технологий.

### 1.1. Коллаборативная фильтрация&#x20;

Все началось с **коллаборативной фильтрации**, популярной еще с 1990-х годов. Этот метод основывался на простой, но мощной идее: люди, которые имели схожие предпочтения в прошлом, вероятно, будут иметь их и в будущем. Если вы и ваш друг любите один и тот же сериал, то, скорее всего, вам понравится другой сериал, который он недавно посмотрел.

Одним из первых методов, применяемых в этой области, был **k-ближайших соседей (k-NN)**. Он искал пользователей или товары с похожими характеристиками, чтобы предсказать, что может понравиться конкретному пользователю.

{% hint style="info" %}
"Если Джейн и ты любите один и тот же сериал, то, возможно, тебе понравится тот, который недавно посмотрела Джейн".
{% endhint %}

Этот подход работал достаточно хорошо, пока система не сталкивалась с так называемой **проблемой холодного старта** — когда появлялся новый пользователь или товар, о которых еще не было никакой информации. В таких случаях алгоритмы не могли предложить ничего интересного, как будто говорили: "Мы пока не знаем, что вам нравится". <mark style="background-color:orange;">Это ограничение стало серьезным вызовом для рекомендательных систем.</mark>

### 1.2. Матричная факторизация

В начале 2000-х годов на смену простым методам пришла **матричная факторизация**. Этот метод приобрел популярность после **Netflix Prize Challenge** в 2006 году, когда команды со всего мира соревновались за создание лучшей модели для предсказания оценок фильмов.

Методы, такие как **SVD (разложение на сингулярные значения)** и **ALS (метод чередующихся наименьших квадратов)**, позволили выявлять скрытые факторы в данных взаимодействий "пользователь-товар". Например, они могли понять, что вам нравятся не просто комедии, а комедии с определенным типом юмора или актером. Эти методы стали золотым стандартом для коллаборативной фильтрации, так как они значительно улучшали качество рекомендаций, выявляя сложные паттерны предпочтений пользователей.

Тем не менее, матричная факторизация тоже имела свои ограничения. Она плохо справлялась с **моделированием сложных, нелинейных зависимостей** и долгосрочных предпочтений, когда, например, ваши вкусы меняются со временем. <mark style="background-color:orange;">Алгоритмы не могли учесть, что на прошлой неделе вы смотрели только комедии, а сейчас вас больше интересуют драмы.</mark>

### 1.3. Контентные и гибридные рекомендации

Чтобы справиться с этими недостатками, исследователи начали развивать **контентные рекомендации**. Такие системы учитывали характеристики самих товаров, такие как описание продукта, жанр фильма или атрибуты пользователя, чтобы предлагать схожие товары. Например, если пользователь предпочитал фильмы в жанре "фантастика", система рекомендовала другие фильмы в этом жанре, анализируя текстовые и мета-данные. Эти методы стали популярными в 2000-х годах, но также имели свои ограничения: они не учитывали поведение других пользователей, а только атрибуты контента.

С течением времени исследователи начали разрабатывать **гибридные модели**, объединяющие коллаборативные и контентные подходы. Это стало особенно популярным в 2010-х годах, когда системы стремились учесть как предпочтения пользователей на основе их поведения, так и характеристики товаров. <mark style="background-color:orange;">Такие модели позволяли создавать более точные и персонализированные рекомендации, но оставались сложными в реализации и оптимизации.</mark>

### 1.4. **Neural Collaborative Filtering**

Следующим значимым шагом в эволюции рекомендательных систем стало использование **глубокого обучения**. В 2017 году появился метод **Neural Collaborative Filtering (NCF)**, который предложил новый подход к коллаборативной фильтрации, сочетая её с возможностями нейронных сетей.

В отличие от традиционных методов, таких как SVD или ALS, которые использовали линейные методы разложения матриц, NCF применял многослойные перцептроны (MLP) для обучения представлений пользователей и товаров. Это означало, что модель могла самостоятельно обучаться оптимальным векторным представлениям, захватывая сложные и нелинейные взаимодействия.

NCF быстро доказала свою эффективность, особенно в сценариях с большими и сложными наборами данных, где традиционные методы не справлялись. Модель могла интегрировать различные типы данных — например, данные о покупках, просмотрах и даже демографические характеристики, — чтобы более точно адаптироваться к пользовательским предпочтениям.

### 1.5. **Convolutional Sequence Embedding Recommendation**

Однако, к 2018 году многие традиционные и новые подходы по-прежнему сталкивались с важной проблемой — **учетом последовательностей взаимодействий пользователей**. В реальном мире поведение пользователя часто носит последовательный характер: он может последовательно просматривать серию видео, покупать несколько товаров в одном заказе или слушать музыкальный плейлист.

Традиционные методы, такие как матричная факторизация или классическая коллаборативная фильтрация, плохо справлялись с учетом порядка этих взаимодействий. Они могли учитывать только факт взаимодействия ("Пользователь A посмотрел Фильм B"), но не учитывали последовательность и временные зависимости между этими действиями. Это означало, что такие методы не могли эффективно предсказывать следующий товар или контент, который пользователь, вероятно, выберет на основе предыдущих действий.&#x20;

С момента проведения конкурса Netflix Prize предпосылки к временным рекомендации показали высокую эффективность в различных задачах за счет явного моделирования временных меток активности пользователей. **TimeSVD++** достигла высоких результатов, разбивая время на несколько сегментов и моделируя пользователей и товары отдельно в каждом из них, но такие рекомендации были очень не гибкими и с большим сдвигом.

Для решения этой проблемы была разработана модель **Caser (Convolutional Sequence Embedding Recommendation Model)**. Представленная в 2018 году, она была ориентирована на задачи **последовательных рекомендаций**, где важно учитывать не только, что пользователь взаимодействовал с определенными товарами, но и в каком порядке это происходило.

Caser представляла последовательность взаимодействий пользователя как "изображение" и использовала свёрточные нейронные сети (CNN) для выявления паттернов в этой последовательности. Такой подход позволял модели захватывать как краткосрочные (локальные) зависимости между недавними взаимодействиями, так и долгосрочные (глобальные) зависимости, охватывающие более длинные последовательности.

Параллельно с этим, в 2017-2018 годах началось активное использование **text embeddings** в рекомендациях. Модели, такие как **Word2Vec**, **GloVe**, **DSSM**, а затем и **BERT**, стали использоваться для создания текстовых представлений товаров и контента, которые затем интегрировались в рекомендательные системы. Эти подходы позволяли учитывать семантические сходства между текстами, улучшая качество рекомендаций в сценариях, где текстовые данные играли важную роль.

***

## 2. Self-Attentive Sequential Recommendation

К 2018 году стало ясно, что для создания по-настоящему точных и персонализированных рекомендаций недостаточно просто учитывать последовательность взаимодействий пользователей с контентом или товарами.&#x20;

Модели, такие как **Caser**, сделали важный шаг вперед, предлагая использовать свёрточные нейронные сети для захвата паттернов в последовательностях действий пользователей. Однако они по-прежнему не могли в полной мере учитывать все сложности этих последовательностей, особенно когда речь шла о более длинных последовательностях с разнородными временными зависимостями.

И на самом деле, как мы дальше и увидим, то Attention в трансформерах это по сути и есть некоторая замена слою свёрток. Несмотря на это трансформеры сами по себе имели и других конкурентов в виде RNN и MCs.

<table data-full-width="true"><thead><tr><th>Markov Chains (MCs)	</th><th width="318.5">Recurrent Neural Networks (RNNs)	</th><th>Convolutional Networks (Caser)	</th><th>Transformers (e.g., SASRec)	</th></tr></thead><tbody><tr><td>Прекрасно работают с разреженными данными и просты в реализации. Хороши в условиях, когда данные имеют высокую разреженность и необходимо учитывать только короткую историю действий.</td><td>Могут моделировать сложные временные зависимости и учитывают порядок элементов. Полезны для задач с последовательными и временными данными.</td><td>Способны захватывать локальные паттерны в данных, что делает их полезными для коротких последовательностей. Легче обучаются по сравнению с RNN и подходят для задач, где важен локальный контекст.</td><td>Могут захватывать как краткосрочные, так и долгосрочные зависимости благодаря механизму самовнимания. Очень гибкие и масштабируемые, могут эффективно обрабатывать длинные последовательности и учитывать сложные взаимодействия между элементами.</td></tr><tr><td>Ограничены в моделировании сложных и долгосрочных зависимостей. Работают плохо в условиях, когда требуется учитывать более длинные последовательности действий пользователя.</td><td>Требуют много данных для эффективного обучения и подвержены проблемам, таким как градиентное затухание. Могут быть вычислительно дорогими и медленными в обучении и прогнозировании.</td><td>Ограничены в способности моделировать долгосрочные зависимости и плохо работают с неравномерными временными интервалами. Используют фиксированные фильтры, что ограничивает их гибкость в захвате более сложных зависимостей.</td><td>Требуют значительных вычислительных ресурсов и могут быть сложными в настройке. Высокие требования к памяти и вычислительной мощности делают их менее подходящими для использования в ограниченных ресурсах.</td></tr></tbody></table>

### 2.1. Что такое Sequential recommendation

**Sequential Recommendation (последовательные рекомендации)** — это подход в рекомендательных системах, который учитывает не только взаимодействия пользователя с товарами или контентом, но и их **порядок**. В отличие от традиционных рекомендаций, которые просто анализируют историю взаимодействий, последовательные рекомендации стремятся понять **контекст** и **последовательность** этих действий, чтобы предсказать следующее наиболее вероятное действие пользователя.

Представим себе реальный сценарий: пользователь заходит на сайт интернет-магазина и совершает следующие действия:

1. $$S^u_1$$​: Сначала он ищет **кроссовки для бега**.
2. ​: Затем добавляет в корзину **спортивную футболку**.
3. $$S^u_3$$​: Далее просматривает **часы для бега с GPS**.
4. $$S^u_4$$​: Наконец, он покупает **бутылку для воды**.

Эти действия можно представить как последовательность:

$$
S^u = (S^u_1, S^u_2, S^u_3, S^u_4)
$$

В данном случае, последовательная рекомендательная система анализирует не только, какие товары были выбраны, но и **в каком порядке** это происходило. Задача модели — предсказать следующее вероятное действие (например, покупку) на основе этой последовательности.

Допустим, после этих действий модель должна предложить пользователю что-то, что логически продолжает эту последовательность. Поскольку пользователь интересовался товарами для бега, модель может порекомендовать ему **компрессионные носки для бега** или **спортивный ремень для хранения телефона и ключей**.

Во время обучения модель учится предсказывать следующее действие, используя сдвиг последовательности на один шаг:

* **Вход**: последовательность действий до текущего шага $$(S^u_1, S^u_2, S^u_3, S^u_4)$$,
* **Выход**: следующее ожидаемое действие $$(S^u_1, S^u_2, S^u_3, S^u_4)$$

То есть, на каждом временном шаге t модель предсказывает следующее действие $$S^u_{t+1}$$​, основываясь на предыдущих t действиях $$(S^u_1, S^u_2, S^u_3, ..., S^u_t)$$. В нашем примере, если t = 3, то входом будет последовательность $$(S^u_1, S^u_2, S^u_3)$$, а модель должна предсказать $$(S^u_4)$$​ — покупку **бутылки для воды**.

Таким образом, последовательные рекомендации позволяют моделям выявлять скрытые паттерны в поведении пользователя и делать более точные и персонализированные предложения, адаптированные к текущему контексту и интересам пользователя.

Этот пример иллюстрирует, как последовательные модели могут учитывать не только выбор пользователя, но и последовательность действий, что делает рекомендации более релевантными и контекстуальными.

### 2.2. Embedding layer

Одним из ключевых компонентов модели **SASRec** является **слой эмбеддингов (embedding layer)**, который позволяет преобразовать последовательность взаимодействий пользователя с элементами (например, товарами или контентом) в векторное представление. Эти векторные представления используются затем в модели для прогнозирования следующего действия пользователя. Давайте подробнее рассмотрим, как это работает.

Первоначально модель получает на вход последовательность идентификаторов элементов, с которыми пользователь взаимодействовал. Например, рассмотрим следующую последовательность элементов: `[item_1, item_2, item_3, ..., item_n]`.

Для работы модели последовательность должна быть приведена к фиксированной длине n, которую мы задаем заранее, по сути это некоторый гиперпараметр, которым мы можем менять контекстное окно.

* Если последовательность действий пользователя длиннее n, мы берем только последние n действий. Это логично, так как недавние действия обычно более релевантны для предсказания следующего действия.
* Если последовательность короче n, к началу последовательности добавляются специальные «пустые» элементы (padding items), чтобы довести длину до n. Это гарантирует, что все последовательности имеют одинаковую длину, что необходимо для эффективного обучения модели.

Каждый элемент в последовательности представляется в виде эмбеддинга фиксированной размерности. Эмбеддинги элементов являются обучаемыми параметрами модели и служат для представления семантического содержания элементов.

Если размерность эмбеддинга `d`, то каждый элемент `item_i` представлен вектором `emb_i` размерности `d`, который можно извлечь из матрицы эмбеддингов `E`:

* `emb_1 = E[item_1]`
* `emb_2 = E[item_2]`
* ...
* `emb_n = E[item_n]`

Здесь `E[item_i]` обозначает векторное представление элемента `item_i` в матрице эмбеддингов `E`.

Механизм self-attention, на котором основана модель SASRec, не имеет информации о порядке элементов в последовательности. Для решения этой проблемы используются позиционные эмбеддинги, которые добавляются к эмбеддингам элементов. Позиционные эмбеддинги также являются обучаемыми параметрами модели.

Для каждой позиции в последовательности добавляется соответствующий позиционный эмбеддинг `P[position]`:

* `emb_1 += P[1]`
* `emb_2 += P[2]`
* ...
* `emb_n += P[n]`

Добавление позиционных эмбеддингов обеспечивает уникальное представление для каждого элемента в зависимости от его положения в последовательности.

После добавления  позиционных эмбеддингов формируется матрица входных эмбеддингов `X` размерностью `(n, d)`, где `n` — это длина последовательности (количество элементов), а `d` — размерность эмбеддинга. Эта матрица затем подается на вход последующим слоям self-attention:

$$
X = [emb_1; emb_2; ...; emb_n]
$$



Здесь символ `;` обозначает конкатенацию векторов по строкам.

### 2.3 Self-Attention





***

## Полезный ссылки

1. [https://arxiv.org/pdf/1808.09781](https://arxiv.org/pdf/1808.09781) - SASRec
2. [https://arxiv.org/pdf/1904.06690](https://arxiv.org/pdf/1904.06690) - Bert4Rec
3. [https://arxiv.org/pdf/2308.07192](https://arxiv.org/pdf/2308.07192) - gSASRec
4. [https://arxiv.org/pdf/2207.07483](https://arxiv.org/pdf/2207.07483) - Bert4Rec or SASRec and etc
5. [https://telegra.ph/Strah-i-nenavist-v-rekomendaciyah-kak-zatashchit-ALBERT4Rec-v-prod-na-1080TI-03-17](https://telegra.ph/Strah-i-nenavist-v-rekomendaciyah-kak-zatashchit-ALBERT4Rec-v-prod-na-1080TI-03-17) - Albert4rec
6. [https://www.youtube.com/watch?v=3\_7AiFq7gvQ](https://www.youtube.com/watch?v=3\_7AiFq7gvQ) - SASRec YouTube
7. [https://arxiv.org/pdf/2212.04120](https://arxiv.org/pdf/2212.04120) - Denoising SASRec
8. [https://arxiv.org/pdf/1907.06902](https://arxiv.org/pdf/1907.06902) - RNN vs MF
9.
